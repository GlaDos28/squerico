<!doctype html>
<html>
    <head>
    	<meta charset="UTF-8" />
    	<title>GlaDos's testing page</title>
    	<script src="js/pixi.js"></script>
    </head>
    <body>
    
    <script type="text/javascript">

	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************

const SQUARE_TYPE_NUMBER = 3;
const SQUARE = new Array(SQUARE_TYPE_NUMBER);

function createSquare(id, assetPath, badgeAssetPath, turnFunc) {
	SQUARE[id] = {
		texture:      PIXI.Texture.fromImage(assetPath),
        	badgeTexture: PIXI.Texture.fromImage(badgeAssetPath),
		turn: turnFunc
	};
}

function getC(f, x, y) {
	if (x < 0 || x >= f.w || y < 0 || y >= f.h)
		return 1;
	else
		return f.c[x][y];
}

/*
 *                               --help
 * 
 * id                      - square identifical unical number
 * assetPath               - path to the field asset
 * badgeAssetPath          - path to the 'selection square' asset
 * turnFunc(in, out, x, y) - field turning function (plot of the square):
 * 	_in  - old field,
 *      _out - new field,
 * 	x    - square X coordinate,
 *      y    - square Y coordinate.
 * 
 * Warning: use getC(f, x, y) to address to the (x, y) cell in field f
 */

//***************** Square 'empty'

const EMPTY = 0;

createSquare(EMPTY, '', 'assets/block-empty.png', function(_in, _out, x, y) {
});

//***************** Square 'wall'

const WALL = 1;

createSquare(WALL, 'assets/block-none.png', 'assets/block-none.png', function(_in, _out, x, y) {
});

//***************** Square 'copy'

const COPY = 2;

createSquare(COPY, 'assets/block-copy.png', 'assets/block-copy.png', function(_in, _out, x, y) {
	var copy = getC(_in, x - 1, y);
	
	if (copy > 1 && getC(_in, x + 1, y + 1) == EMPTY && getC(_in, x + 1, y - 1) == EMPTY) {
		_out.c[x - 1][y] = EMPTY;
		_out.c[x + 1][y + 1] = copy;
		_out.c[x + 1][y - 1] = copy;
	}
});

//***************** Square 'move'

const MOVE = 3;

createSquare(MOVE, 'assets/block-move.png', 'assets/block-move.png', function(_in, _out, x, y) {
	var move = getC(_in, x + 1, y);
	
	if (move > 1 && getC(_in, x + 2, y) == EMPTY && getC(_in, x + 3, y) == EMPTY) {
		_out.c[x + 1][y] = EMPTY;
		_out.c[x + 3][y] = move;
	}
});

/////////////////////////////////////////////////////////
// TODO paste your squares (the same way as above) here//
/////////////////////////////////////////////////////////
    	
    	
    	
    	
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	
    	
function emptyField(w, h, emptyType, wallType) {
	var c = new Array(w);
	
	for (var i = 0; i < w; i++) {
		c[i] = new Array(h);
		
		for (var j = 0; j < h; j++)
			c[i][j] = emptyType;
	}
	
	for (var i = 0; i < w; i++) {
		c[i][0] = wallType;
		c[i][h - 1] = wallType;
	}
	
	for (var i = 0; i < h; i++) {
		c[0][i] = wallType;
		c[w - 1][i] = wallType;
	}
	
	return { w: w, h: h, c: c };
}

function createField(c) {
	var _c = new Array(c[0].length);
	
	for (var i = 0; i < c[0].length; i++) {
		_c[i] = new Array(c.length);
		
		for (var j = 0; j < c.length; j++)
			_c[i][j] = c[j][i];
	}
	
	return { w: c[0].length, h: c.length, c: _c };
}

function copyField(pattern) {
	var c = new Array(pattern.w);
	
	for (var i = 0; i < pattern.w; i++) {
		c[i] = new Array(pattern.h);
		
		for (var j = 0; j < pattern.h; j++)
			c[i][j] = pattern.c[i][j];
	}
	
	return { w: pattern.w, h: pattern.h, c: c };
}

const FIELDS = [
	createField([
		[ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
	        [ 1, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 1 ],
      	        [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 1 ],
	        [ 1, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 1 ],
            	[ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 1 ],
	        [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 ],
	        [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
	])
];
    	
    	
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	

function createSession(field, square) {
	return { f: field, s: square };
}

function turnSession(session) {
	var newF = copyField(session.f);
	
	for (var i = 0; i < newF.h; i++)
		for (var j = 0; j < newF.w; j++)
			session.s[session.f.c[i][j]].turn(session.f, newF, i, j);
	
	session.f = newF;
}
    	
    	
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	//****************************************************************
    	
	var session = createSession(FIELDS[0], SQUARE);
	
	const DELAY_TURN_TIME = 6;
	const DELAY_DRAW_TIME = 2;
	const FIELD = { squareSize: 48,
	                squareOffset: { x: 16.25, y: 12.4 },
	                start: { x: 20,
				 y: 50 },
			end: { x: 50 + session.f.w * 64,
			       y: 50 + session.f.h * 60 } };
	const BACKGROUND_COLOR = 0x1099bb;
	const BADGE = { size: 75, pos: [ { x: 1175, y: 75 },
	                                 { x: 1175, y: 175 },
	                                 { x: 1175, y: 275 }, 
	                                 { x: 1175, y: 375 } ] };
	
	//**********************************************
	
        var renderer = PIXI.autoDetectRenderer(1300, 1150, { backgroundColor: BACKGROUND_COLOR });
        document.body.appendChild(renderer.view);
        
        var stage = new PIXI.Container();
        stage.interactive = true;
        
        //**********************************************
        
        var logo = new PIXI.Sprite(PIXI.Texture.fromImage('assets/idp.jpg'));
        
        logo.anchor.x = 0.8;
        logo.anchor.y = 0.8;
        
        logo.scale.set(0.285);
        
        logo.position.x = 1256;
        logo.position.y = 1076;
        
        //**********************************************
        
        var field = new Array(session.f.w);
        
        for (var i = 0; i < session.f.w; i++) {
		field[i] = new Array(session.f.h);
		
		for (var j = 0; j < session.f.h; j++) {
			field[i][j] = new PIXI.Sprite(PIXI.Texture.fromImage('assets/block-empty.png'));
			field[i][j].position.x = FIELD.start.x + 50 + (FIELD.squareSize + FIELD.squareOffset.x) * i;
			field[i][j].position.y = FIELD.start.y + 50 + (FIELD.squareSize + FIELD.squareOffset.y) * j;
		}
        }
        
        //**********************************************
        
        var graphics = new PIXI.Graphics();
        var timerTurn = 0;
        var timerDraw = 0;
        var pause = false;
        var paintBlock = 0;
        
        //**
        
        var interactRect = new PIXI.Graphics();
        interactRect.lineStyle(0, 0x000000, 1);
	interactRect.beginFill(BACKGROUND_COLOR, 1);
	interactRect.drawRect(FIELD.start.x, FIELD.start.y, FIELD.end.x - FIELD.start.x, FIELD.end.y - FIELD.start.y);
	interactRect.endFill();
        
        //**
        
        var basicText = new PIXI.Text("Pause");
        
	basicText.x = (FIELD.start.x + FIELD.end.x) / 2;;
	basicText.y = 10;
	
	basicText.interactive = true;
	
	basicText.on('click', onPauseClick);
	basicText.on('tap', onPauseClick);
	
	//**********************************************
	
	var background = { fieldBG: new PIXI.Sprite(PIXI.Texture.fromImage('assets/game-field.png')),
	                   g:       new PIXI.Graphics(),
	                   badge:   new Array(session.s.length) };
	
	background.fieldBG.position.x = FIELD.start.x;
	background.fieldBG.position.y = FIELD.start.y;
	
	background.g.lineStyle(4, 0x0000DF, 1);
	background.g.beginFill(BACKGROUND_COLOR, 1);
	background.g.drawRect(1145, 50, 140, 1055);
	background.g.endFill();
	
	for (var i = 0; i < session.s.length; i++) {
		background.badge[i] = new PIXI.Sprite(session.s[i].badgeTexture);
		background.badge[i].anchor.x = -0.1;
		background.badge[i].anchor.y = -0.1;
		background.badge[i].position.x = BADGE.pos[i].x;
		background.badge[i].position.y = BADGE.pos[i].y;
	}
	
	//**********************************************
	
	stage.addChild(interactRect);
	stage.addChild(background.fieldBG);
	stage.addChild(background.g);
	stage.addChild(basicText);
	stage.addChild(logo);
	
	for (var i = 0; i < session.f.w; i++)
		for (var j = 0; j < session.f.h; j++)
			stage.addChild(field[i][j]);
	
	for (var i = 0; i < session.s.length; i++)
		stage.addChild(background.badge[i]);
	
	stage.on('click', onClick);
	stage.on('tap', onClick);
	
	//**********************************************
	
	function inRect(p, rectP, w, h) {
		return p.x >= rectP.x     &&
		       p.y >= rectP.y     &&
		       p.x <= rectP.x + w &&
		       p.y <= rectP.y + h;
	}
	
	//**********************************************
	
	function onPauseClick(event) {
		pause = !pause;
	}
	
	function onClick(event) {
		var p = event.data.getLocalPosition(this)
		
		for (var i = 0; i < BADGE.pos.length; i++)
			if (inRect(p, BADGE.pos[i], BADGE.size, BADGE.size)) {
				paintBlock = i;
				break;
			}
		
		if (	p.x < FIELD.start.x - 46 ||
			p.y < FIELD.start.y - 50 ||
			p.x > FIELD.end.x + 46   ||
			p.y > FIELD.end.y + 50      ) 
		    return;
		
		p.x -= FIELD.start.x + 46;
		p.y -= FIELD.start.y + 50;
		
		p.x /= FIELD.squareSize + FIELD.squareOffset.x;
		p.y /= FIELD.squareSize + FIELD.squareOffset.y;
		
		var intX = Math.floor(p.x);
		var intY = Math.floor(p.y);
		
		session.f.c[intX][intY] = paintBlock;
	}
	
	//**********************************************
	
        animate();
        function animate() {
		if (!pause)
			timerTurn++;
		
		timerDraw++;
		
		if (timerDraw >= DELAY_DRAW_TIME) {
			timerDraw = 0;
			
			for (var i = 0; i < session.f.w; i++)
				for (var j = 0; j < session.f.h; j++)
					field[i][j].texture = session.s[session.f.c[i][j]].texture;
			
			graphics = new PIXI.Graphics();
			graphics.lineStyle(2, 0x00FF00, 1);
			graphics.beginFill(0x000000, 0);
			graphics.drawRect(BADGE.pos[paintBlock].x, BADGE.pos[paintBlock].y, BADGE.size, BADGE.size);
			graphics.endFill();
		}
		
		if (timerTurn >= DELAY_TURN_TIME) {
			timerTurn = 0;
			turnSession(session);
		}
		
		stage.addChild(graphics);
		
		requestAnimationFrame(animate);
		renderer.render(stage);
		
		stage.removeChild(graphics);
        }
        
    </script>

  </body>
</html>

